
---

### **Û±. Ù…Ù‚Ø¯Ù…Ù‡â€ŒØ§ÛŒ Ø¨Ø± Ø§ÙˆØ±Ø§Ù‚ Ø®Ø²Ø§Ù†Ù‡ Ø¨Ø¯ÙˆÙ† Ú©ÙˆÙ¾ÙˆÙ†**

Ø§ÙˆØ±Ø§Ù‚ Ø®Ø²Ø§Ù†Ù‡ Ø¨Ø¯ÙˆÙ† Ú©ÙˆÙ¾ÙˆÙ† Ø§ÙˆØ±Ø§Ù‚ Ù‚Ø±Ø¶Ù‡â€ŒØ§ÛŒ Ù‡Ø³ØªÙ†Ø¯ Ú©Ù‡ Ø¨Ù‡ Ø³Ø±Ù…Ø§ÛŒÙ‡â€ŒÚ¯Ø°Ø§Ø±Ø§Ù† Ù‡ÛŒÚ†â€ŒÚ¯ÙˆÙ†Ù‡ Ø¨Ù‡Ø±Ù‡ (Ú©ÙˆÙ¾ÙˆÙ†) Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ù…ÛŒâ€ŒÚ©Ù†Ù†Ø¯. Ø¨Ù‡ Ø¬Ø§ÛŒ Ø¢Ù†ØŒ Ø§ÛŒÙ† Ø§ÙˆØ±Ø§Ù‚ Ø¨Ø§ ØªØ®ÙÛŒÙ Ø§Ø² Ø§Ø±Ø²Ø´ Ø§Ø³Ù…ÛŒ Ø®ÙˆØ¯ ØµØ§Ø¯Ø± Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ Ùˆ Ø¯Ø± ØªØ§Ø±ÛŒØ® Ø³Ø±Ø±Ø³ÛŒØ¯ Ø¨Ù‡ Ø¯Ø§Ø±Ù†Ø¯Ù‡â€ŒÛŒ Ø¢Ù†ØŒ Ù…Ø¨Ù„Øº Ø§Ø³Ù…ÛŒ Ú©Ø§Ù…Ù„ Ù¾Ø±Ø¯Ø§Ø®Øª Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø³ÙˆØ¯ Ø³Ø±Ù…Ø§ÛŒÙ‡â€ŒÚ¯Ø°Ø§Ø± Ø§Ø² ØªÙØ§ÙˆØª Ø¨ÛŒÙ† Ù‚ÛŒÙ…Øª Ø®Ø±ÛŒØ¯ Ø§ÙˆØ±Ø§Ù‚ Ùˆ Ù…Ø¨Ù„Øº Ù¾Ø±Ø¯Ø§Ø®Øª Ø´Ø¯Ù‡ Ø¯Ø± Ø³Ø±Ø±Ø³ÛŒØ¯ Ù†Ø§Ø´ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯.

**ÙØ±Ù…ÙˆÙ„ Ù‚ÛŒÙ…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø§ÙˆØ±Ø§Ù‚ Ø®Ø²Ø§Ù†Ù‡ Ø¨Ø¯ÙˆÙ† Ú©ÙˆÙ¾ÙˆÙ†:**

![Equation](https://latex.codecogs.com/png.latex?P%20%3D%20%5Cfrac%7BF%7D%7B%281&plus;r%29%5ET%7D)

Ú©Ù‡ Ø¯Ø± Ø¢Ù†:
- \( P \) Ù‚ÛŒÙ…Øª Ø§ÙˆØ±Ø§Ù‚ Ø§Ø³Øª.
- \( F \) Ø§Ø±Ø²Ø´ Ø§Ø³Ù…ÛŒ Ø§ÙˆØ±Ø§Ù‚ Ø§Ø³Øª.
- \( r \) Ù†Ø±Ø® Ø¨Ø§Ø²Ø¯Ù‡ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø± (Yield to Maturity) Ø§Ø³Øª.
- \( T \) Ø²Ù…Ø§Ù† ØªØ§ Ø³Ø±Ø±Ø³ÛŒØ¯ Ø§ÙˆØ±Ø§Ù‚ (Ø¨Ø± Ø­Ø³Ø¨ Ø³Ø§Ù„) Ø§Ø³Øª.

---

### **Û². Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ø³ÛŒÚ†Ú© Ùˆ CIR Ø¯Ø± Ù‚ÛŒÙ…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø§ÙˆØ±Ø§Ù‚**

Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ **ÙˆØ§Ø³ÛŒÚ†Ú©** Ùˆ **CIR** Ø¯Ùˆ Ù…Ø¯Ù„ Ù…Ø´Ù‡ÙˆØ± Ø¯Ø± Ù…Ø§Ù„ÛŒ Ù‡Ø³ØªÙ†Ø¯ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ ØªÙˆØµÛŒÙ ÙØ±Ø¢ÛŒÙ†Ø¯Ù‡Ø§ÛŒ ØªØµØ§Ø¯ÙÛŒ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯. Ø§ÛŒÙ† Ù…Ø¯Ù„â€ŒÙ‡Ø§ Ø¨Ù‡ Ù…Ø§ Ø§Ø¬Ø§Ø²Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ù†Ø¯ ØªØ§ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø±Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† ÛŒÚ© ÙØ±Ø¢ÛŒÙ†Ø¯ ØªØµØ§Ø¯ÙÛŒ Ù…Ø¯Ù„â€ŒØ³Ø§Ø²ÛŒ Ú©Ù†ÛŒÙ… Ùˆ Ø§Ø² Ø¢Ù† Ø¨Ø±Ø§ÛŒ Ù‚ÛŒÙ…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø§ÙˆØ±Ø§Ù‚ Ù‚Ø±Ø¶Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒÙ….

#### **Û².Û±. Ù…Ø¯Ù„ ÙˆØ§Ø³ÛŒÚ†Ú© (Vasicek Model)**

Ù…Ø¯Ù„ ÙˆØ§Ø³ÛŒÚ†Ú© ÛŒÚ©ÛŒ Ø§Ø² Ø§ÙˆÙ„ÛŒÙ† Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ ØªØµØ§Ø¯ÙÛŒ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø§Ø³Øª Ú©Ù‡ ØªÙˆØ³Ø· ÙØ±ÛŒØªØ² ÙˆØ§Ø³ÛŒÚ†Ú© Ø¯Ø± Ø³Ø§Ù„ Û±Û¹Û·Û· Ù…Ø¹Ø±ÙÛŒ Ø´Ø¯. Ø§ÛŒÙ† Ù…Ø¯Ù„ ÙØ±Ø¶ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ú©Ù‡ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ ØªØ­Øª ØªØ£Ø«ÛŒØ± Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø¨Ù„Ù†Ø¯Ù…Ø¯Øª (\( \theta \))ØŒ Ù…ÛŒØ²Ø§Ù† ØªÙ…Ø§ÛŒÙ„ Ø¨Ù‡ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø§ÛŒÙ† Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† (\( \kappa \)) Ùˆ Ù†ÙˆØ³Ø§Ù†Ø§Øª (\( \sigma \)) Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ø¯.

**ÙØ±Ù…ÙˆÙ„ Ù…Ø¯Ù„ ÙˆØ§Ø³ÛŒÚ†Ú©:**

![Vasicek Equation](https://latex.codecogs.com/png.latex?dr_t%20%3D%20%5Ckappa%20%28%5Ctheta%20-%20r_t%29%20dt%20&plus;%20%5Csigma%20dW_t)

Ú©Ù‡ Ø¯Ø± Ø¢Ù†:
- \( r_t \) Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø¯Ø± Ø²Ù…Ø§Ù† \( t \) Ø§Ø³Øª.
- \( \kappa \) Ù†Ø±Ø® Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø§Ø³Øª.
- \( \theta \) Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø¨Ù„Ù†Ø¯Ù…Ø¯Øª Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø§Ø³Øª.
- \( \sigma \) Ù†ÙˆØ³Ø§Ù†Ø§Øª Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø§Ø³Øª.
- \( dW_t \) Ù†Ù…Ø§ÛŒØ§Ù†Ú¯Ø± ÙØ±Ø¢ÛŒÙ†Ø¯ Ø¨Ø±Ø§ÙˆÙ†ÛŒ Ø§Ø³Øª.

**Ù‚ÛŒÙ…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø§ÙˆØ±Ø§Ù‚ Ø¨Ø¯ÙˆÙ† Ú©ÙˆÙ¾ÙˆÙ† Ø¨Ø§ Ù…Ø¯Ù„ ÙˆØ§Ø³ÛŒÚ†Ú©:**

![Vasicek Bond Price](https://latex.codecogs.com/png.latex?P%20%3D%20A(T)%20%5Ccdot%20e%5E%7B-B(T)%20r_0%7D)

Ú©Ù‡ Ø¯Ø± Ø¢Ù†:
- \( A(T) \) Ùˆ \( B(T) \) ØªÙˆØ§Ø¨Ø¹ÛŒ Ù‡Ø³ØªÙ†Ø¯ Ú©Ù‡ Ø¨Ù‡ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ù…Ø¯Ù„ Ø¨Ø³ØªÚ¯ÛŒ Ø¯Ø§Ø±Ù†Ø¯.
- \( r_0 \) Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø§ÙˆÙ„ÛŒÙ‡ Ø§Ø³Øª.

**Ø¯Ø± Ú©Ø¯ Streamlit:**

Ø¯Ø± Ú©Ù„Ø§Ø³ `VasicekModel`ØŒ Ù…ØªØ¯ `analytic_bond_price` Ø§ÛŒÙ† ÙØ±Ù…ÙˆÙ„ Ø±Ø§ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯:

```python
def analytic_bond_price(self, T: float) -> float:
    try:
        kappa = self.params['kappa']
        theta = self.params['theta']
        sigma = self.params['sigma']
        r0 = self.params['X0']

        B_T = (1 - np.exp(-kappa * T)) / kappa
        A_T = np.exp(
            (theta - (sigma**2) / (2 * kappa**2)) * (B_T - T)
            - (sigma**2 / (4 * kappa)) * B_T**2
        )
        P = A_T * np.exp(-B_T * r0)
        return P
    except Exception as e:
        self.logger.error(f"Error calculating analytic bond price at T={T}: {e}")
        return np.nan
```

---

#### **Û².Û². Ù…Ø¯Ù„ CIR (Cox-Ingersoll-Ross Model)**

Ù…Ø¯Ù„ CIR Ú©Ù‡ ØªÙˆØ³Ø· Ø¬Ø§Ù† Ø³ÛŒ. Ú©ÙˆÚ©Ø³ØŒ Ø¬Ø§Ù† Ù‡. Ø§ÛŒÙ†Ú¯Ø±Ø³ÙˆÙ„ Ùˆ Ø³ÙˆØ±Ù† Ø±ÙˆØ³ Ø¯Ø± Ø³Ø§Ù„ Û±Û¹Û¸Ûµ Ù…Ø¹Ø±ÙÛŒ Ø´Ø¯ØŒ Ù…Ø´Ø§Ø¨Ù‡ Ù…Ø¯Ù„ ÙˆØ§Ø³ÛŒÚ†Ú© Ø§Ø³Øª Ø§Ù…Ø§ ÙˆÛŒÚ˜Ú¯ÛŒ Ø§Ø¶Ø§ÙÙ‡â€ŒØ§ÛŒ Ø¯Ø§Ø±Ø¯ Ú©Ù‡ Ø§Ø¬Ø§Ø²Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø¨Ù‡ Ø·ÙˆØ± Ø·Ø¨ÛŒØ¹ÛŒ Ø¨Ù‡ Ø³Ù…Øª ØµÙØ± Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø¯ØŒ Ú©Ù‡ Ø§ÛŒÙ† Ø§Ù…Ø± Ø¯Ø± Ù…Ø¯Ù„ ÙˆØ§Ø³ÛŒÚ†Ú© ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.

**ÙØ±Ù…ÙˆÙ„ Ù…Ø¯Ù„ CIR:**

![CIR Equation](https://latex.codecogs.com/png.latex?dr_t%20%3D%20%5Ckappa%20%28%5Ctheta%20-%20r_t%29%20dt%20&plus;%20%5Csigma%20%5Csqrt%7Br_t%7D%20dW_t)

Ú©Ù‡ Ø¯Ø± Ø¢Ù†:
- ØªÙ…Ø§Ù…ÛŒ Ù†Ù…Ø§Ø¯Ù‡Ø§ Ù…Ø´Ø§Ø¨Ù‡ Ù…Ø¯Ù„ ÙˆØ§Ø³ÛŒÚ†Ú© Ù‡Ø³ØªÙ†Ø¯ØŒ Ø¨Ø§ Ø§ÛŒÙ† ØªÙØ§ÙˆØª Ú©Ù‡ Ù†ÙˆØ³Ø§Ù†Ø§Øª Ø¨Ø§ Ø±ÛŒØ´Ù‡â€ŒÛŒ Ù…Ø±Ø¨Ø¹ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø¶Ø±ÛŒØ¨ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ØŒ Ú©Ù‡ Ø¨Ø§Ø¹Ø« Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù…Ù†ÙÛŒ Ø´ÙˆØ¯.

**Ù‚ÛŒÙ…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø§ÙˆØ±Ø§Ù‚ Ø¨Ø¯ÙˆÙ† Ú©ÙˆÙ¾ÙˆÙ† Ø¨Ø§ Ù…Ø¯Ù„ CIR:**

![CIR Bond Price](https://latex.codecogs.com/png.latex?P%20%3D%20A(T)%20%5Ccdot%20e%5E%7B-B(T)%20r_0%7D)

Ú©Ù‡ Ø¯Ø± Ø¢Ù†:
- \( A(T) \) Ùˆ \( B(T) \) ØªÙˆØ§Ø¨Ø¹ÛŒ Ù‡Ø³ØªÙ†Ø¯ Ú©Ù‡ Ø¨Ù‡ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ù…Ø¯Ù„ Ø¨Ø³ØªÚ¯ÛŒ Ø¯Ø§Ø±Ù†Ø¯.

**Ø¯Ø± Ú©Ø¯ Streamlit:**

Ø¯Ø± Ú©Ù„Ø§Ø³ `CIRModel`, Ù…ØªØ¯ `analytic_bond_price` Ø§ÛŒÙ† ÙØ±Ù…ÙˆÙ„ Ø±Ø§ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯:

```python
def analytic_bond_price(self, T: float) -> float:
    try:
        kappa = self.params['kappa']
        theta = self.params['theta']
        sigma = self.params['sigma']
        r0 = self.params['X0']

        h = np.sqrt(kappa**2 + 2 * sigma**2)
        numerator = 2 * h * np.exp((kappa + h) * T / 2)
        denominator = (2 * h + (kappa + h) * (np.exp(h * T) - 1))
        A = (numerator / denominator) ** (2 * kappa * theta / sigma**2)
        B = (2 * (np.exp(h * T) - 1)) / (2 * h + (kappa + h) * (np.exp(h * T) - 1))
        P = A * np.exp(-B * r0)
        return P
    except Exception as e:
        self.logger.error(f"Error calculating analytic bond price at T={T}: {e}")
        return np.nan
```

---

### **Û³. ØªÙˆØ¶ÛŒØ­ ÙØ±Ø¢ÛŒÙ†Ø¯ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚ÛŒÙ…Øª Ø§ÙˆØ±Ø§Ù‚ Ø®Ø²Ø§Ù†Ù‡ Ø¨Ø¯ÙˆÙ† Ú©ÙˆÙ¾ÙˆÙ† Ø¨Ø§ Ø³Ø§Ø®ØªØ§Ø± Ø¯Ø±Ø®ØªÛŒ**

Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚ÛŒÙ…Øª Ø§ÙˆØ±Ø§Ù‚ Ø®Ø²Ø§Ù†Ù‡ Ø¨Ø¯ÙˆÙ† Ú©ÙˆÙ¾ÙˆÙ† Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ø³ÛŒÚ†Ú© Ùˆ CIRØŒ ÙØ±Ø¢ÛŒÙ†Ø¯ Ø²ÛŒØ± Ø±Ø§ Ø¯Ù†Ø¨Ø§Ù„ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…:

#### **Û³.Û±. Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ùˆ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§**
- **Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯Ù†ÛŒØ§Ø²:**
  - Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ ØªØ§Ø±ÛŒØ®ÛŒ (Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù„ÛŒØ¨Ø±Ø§Ø³ÛŒÙˆÙ† Ù…Ø¯Ù„â€ŒÙ‡Ø§)
  - Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§ÙˆØ±Ø§Ù‚ Ù‚Ø±Ø¶Ù‡:
    - Ø§Ø±Ø²Ø´ Ø§Ø³Ù…ÛŒ (Face Value)
    - Ø²Ù…Ø§Ù† ØªØ§ Ø³Ø±Ø±Ø³ÛŒØ¯ (Maturity)
    - Ù‚ÛŒÙ…Øª Ø¨Ø§Ø²Ø§Ø± (Market Price)
- **Ø§Ù‚Ø¯Ø§Ù…Ø§Øª Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ:**
  - Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§: Ø­Ø°Ù Ù…Ù‚Ø§Ø¯ÛŒØ± Ø®Ø§Ù„ÛŒ ÛŒØ§ Ø§Ø´ØªØ¨Ø§Ù‡.
  - Ù†Ø±Ù…Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ: ØªØ¨Ø¯ÛŒÙ„ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø¨Ù‡ Ù…Ù‚ÛŒØ§Ø³ Ø³Ø§Ù„Ø§Ù†Ù‡ (Ø§Ú¯Ø± Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø¨Ø§Ø´Ø¯).
  - ØªØ¨Ø¯ÛŒÙ„ Ø²Ù…Ø§Ù† Ø³Ø±Ø±Ø³ÛŒØ¯ Ø¨Ù‡ Ø³Ø§Ù„ (Ù…Ø«Ù„Ø§Ù‹ ØªØ¨Ø¯ÛŒÙ„ Ø±ÙˆØ²Ù‡Ø§ Ø¨Ù‡ Ø³Ø§Ù„).

#### **Û³.Û². Ø§Ù†ØªØ®Ø§Ø¨ Ù…Ø¯Ù„ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡**
- **Ø¯Ùˆ Ù…Ø¯Ù„ Ø§ØµÙ„ÛŒ:**
  1. **Ù…Ø¯Ù„ ÙˆØ§Ø³ÛŒÚ†Ú©**
  2. **Ù…Ø¯Ù„ CIR**

#### **Û³.Û³. Ú©Ø§Ù„ÛŒØ¨Ø±Ø§Ø³ÛŒÙˆÙ† Ù…Ø¯Ù„**
- **Ù‡Ø¯Ù:** ØªØ®Ù…ÛŒÙ† Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ù…Ø¯Ù„ (\( \kappa \), \( \theta \), \( \sigma \)).
- **Ø±ÙˆØ´â€ŒÙ‡Ø§:**
  - Ø­Ø¯Ø§Ú©Ø«Ø± Ø¯Ø±Ø³Øªâ€ŒÙ†Ù…Ø§ÛŒÛŒ (Maximum Likelihood Estimation - MLE)
  - Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ ØªØ±Ú©ÛŒØ¨ÛŒ (Differential Evolution Ùˆ L-BFGS-B)

#### **Û³.Û´. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚ÛŒÙ…Øª Ø§ÙˆØ±Ø§Ù‚**
- **Ø±ÙˆØ´ Û±: ØªØ­Ù„ÛŒÙ„â€ŒÚ¯Ø±Ø§Ù†Ù‡**
  - Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙØ±Ù…ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Ø¨Ø³ØªÙ‡ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ \( A(T) \) Ùˆ \( B(T) \).
  - Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚ÛŒÙ…Øª Ù†Ù‡Ø§ÛŒÛŒ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§ÛŒÙ† ØªÙˆØ§Ø¨Ø¹ Ùˆ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ø§ÙˆÙ„ÛŒÙ‡.
- **Ø±ÙˆØ´ Û²: Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù…ÙˆÙ†Øªâ€ŒÚ©Ø§Ø±Ù„Ùˆ**
  - ØªÙˆÙ„ÛŒØ¯ Ù…Ø³ÛŒØ±Ù‡Ø§ÛŒ ØªØµØ§Ø¯ÙÛŒ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡.
  - Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ù‚Ø¯Ø§Ø± ØªÙ†Ø²ÛŒÙ„â€ŒØ´Ø¯Ù‡ (Discounted Value) Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù…Ø³ÛŒØ±.
  - Ù…ÛŒØ§Ù†Ú¯ÛŒÙ†â€ŒÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù†ØªØ§ÛŒØ¬ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ®Ù…ÛŒÙ† Ù‚ÛŒÙ…Øª.

#### **Û³.Ûµ. Ù…Ù‚Ø§ÛŒØ³Ù‡ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§**
- **ØªØ­Ù„ÛŒÙ„:**
  - Ù…Ù‚Ø§ÛŒØ³Ù‡ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ ØªØ­Ù„ÛŒÙ„â€ŒÚ¯Ø±Ø§Ù†Ù‡ Ùˆ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø§ Ù‚ÛŒÙ…Øª Ø¨Ø§Ø²Ø§Ø±.
  - Ø¨Ø±Ø±Ø³ÛŒ ØªÙØ§ÙˆØªâ€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø§ÙˆØ±Ø§Ù‚ Ú©Ù…â€ŒØ§Ø±Ø²Ø´â€ŒÚ¯Ø°Ø§Ø±ÛŒâ€ŒØ´Ø¯Ù‡ ÛŒØ§ Ø¨ÛŒØ´â€ŒØ§Ø±Ø²Ø´â€ŒÚ¯Ø°Ø§Ø±ÛŒâ€ŒØ´Ø¯Ù‡.

---

### **Û´. Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø± Ú©Ø¯ Streamlit**

Ø¯Ø± Ú©Ø¯ Ø§Ø±Ø§Ø¦Ù‡ Ø´Ø¯Ù‡ØŒ ØªÙ…Ø§Ù…ÛŒ Ù…Ø±Ø§Ø­Ù„ ÙÙˆÙ‚ Ø¨Ù‡ ØµÙˆØ±Øª Ø³Ø§Ø®ØªØ§Ø±ÛŒ Ùˆ Ø¯Ø± Ù‚Ø§Ù„Ø¨ Ú©Ù„Ø§Ø³â€ŒÙ‡Ø§ Ùˆ ØªÙˆØ§Ø¨Ø¹ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯. Ø¯Ø± Ø§Ø¯Ø§Ù…Ù‡ØŒ ØªÙˆØ¶ÛŒØ­Ø§ØªÛŒ Ø¯Ø± Ù…ÙˆØ±Ø¯ Ù‡Ø± Ø¨Ø®Ø´ Ø§Ø² Ú©Ø¯ Ø§Ø±Ø§Ø¦Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ù…:

#### **Û´.Û±. Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ùˆ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§**

Ú©Ù„Ø§Ø³ `DataLoader` Ù…Ø³Ø¦ÙˆÙ„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ùˆ Ø§ÙˆØ±Ø§Ù‚ Ø§Ø³Øª. Ø§ÛŒÙ† Ú©Ù„Ø§Ø³ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ØªØ§Ø¨Ø¹ `map_columns_with_fuzzy_matching` Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ù‡ Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ ØªØ¨Ø¯ÛŒÙ„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø­Ø§ØµÙ„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ú©Ù‡ ØªÙ…Ø§Ù…ÛŒ Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ù…ÙˆØ¬ÙˆØ¯ Ù‡Ø³ØªÙ†Ø¯.

```python
class DataLoader:
    """
    Handles loading and processing of interest rate and bonds data.
    """

    def __init__(self, logger: logging.Logger):
        self.logger = logger

    def load_interest_rate_data(self, uploaded_file) -> Optional[pd.DataFrame]:
        # Implementation as described earlier
        ...

    def load_bonds_data(self, uploaded_file) -> Optional[pd.DataFrame]:
        # Implementation as described earlier
        ...
```

#### **Û´.Û². ØªØ®Ù…ÛŒÙ† Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ù…Ø¯Ù„**

Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù…Ø¯Ù„ (ÙˆØ§Ø³ÛŒÚ†Ú© Ùˆ CIR)ØŒ Ú©Ù„Ø§Ø³â€ŒÙ‡Ø§ÛŒ `VasicekModel` Ùˆ `CIRModel` Ù…Ø³Ø¦ÙˆÙ„ ØªØ®Ù…ÛŒÙ† Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ \( \kappa \), \( \theta \), \( \sigma \), Ùˆ \( X0 \) Ù‡Ø³ØªÙ†Ø¯. Ø§ÛŒÙ† ØªØ®Ù…ÛŒÙ†â€ŒÙ‡Ø§ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…Ø§Ù†Ù†Ø¯ **Differential Evolution** Ùˆ **MLE (Maximum Likelihood Estimation)** Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.

```python
class VasicekModel:
    """
    Handles Vasicek model parameter estimation and bond pricing.
    """
    def __init__(self, ir_series: pd.Series, logger: logging.Logger):
        self.ir_series = ir_series
        self.logger = logger
        self.params: Dict[str, Any] = {}

    def estimate_parameters(self) -> Dict[str, Any]:
        # Implementation as described earlier
        ...

    def predict_interest_rate(self, T: float) -> Dict[str, Any]:
        # Implementation as described earlier
        ...

    def analytic_bond_price(self, T: float) -> float:
        # Implementation as described earlier
        ...
```

#### **Û´.Û³. Ù‚ÛŒÙ…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø§ÙˆØ±Ø§Ù‚**

Ù¾Ø³ Ø§Ø² ØªØ®Ù…ÛŒÙ† Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ØŒ Ú©Ù„Ø§Ø³ `BondPricer` Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…ØªØ¯Ù‡Ø§ÛŒ `analytic_bond_price` Ùˆ `monte_carlo_bond_price`ØŒ Ù‚ÛŒÙ…Øª Ø§ÙˆØ±Ø§Ù‚ Ø±Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯. Ù‚ÛŒÙ…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ ØªØ­Ù„ÛŒÙ„â€ŒÚ¯Ø±Ø§Ù†Ù‡ (Analytic Price) Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙØ±Ù…ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ø³ÛŒÚ†Ú© Ùˆ CIR Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŒ Ø¯Ø± Ø­Ø§Ù„ÛŒ Ú©Ù‡ Ù‚ÛŒÙ…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ù…ÙˆÙ†Øªâ€ŒÚ©Ø§Ø±Ù„Ùˆ (Monte Carlo Price) Ø¨Ø§ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù…Ø³ÛŒØ±Ù‡Ø§ÛŒ Ù†Ø±Ø® Ø¨Ù‡Ø±Ù‡ Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØ®ÙÛŒÙâ€ŒÙ‡Ø§ÛŒ Ù…Ø±Ø¨ÙˆØ·Ù‡ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒÙ¾Ø°ÛŒØ±Ø¯.

```python
class BondPricer:
    """
    Handles bulk bond pricing using different methods and predicts interest rates at maturity.
    """
    def __init__(self, model, logger: logging.Logger):
        self.model = model
        self.logger = logger

    def price_bond(self, bond: pd.Series) -> Dict[str, Any]:
        # Implementation as described earlier
        ...

    def monte_carlo_bond_price(self, T: float) -> Tuple[float, float]:
        # Implementation as described earlier
        ...

    def price_bulk_bonds(self, bonds_df: pd.DataFrame) -> pd.DataFrame:
        # Implementation as described earlier
        ...
```

#### **Û´.Û´. ØªÙˆØµÛŒÙ‡ Ùˆ Ø±ØªØ¨Ù‡â€ŒØ¨Ù†Ø¯ÛŒ Ø§ÙˆØ±Ø§Ù‚**

ØªØ§Ø¨Ø¹ `rank_bonds` Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø±ØªØ¨Ù‡â€ŒØ¨Ù†Ø¯ÛŒ Ø§ÙˆØ±Ø§Ù‚ Ø§Ø¹Ù…Ø§Ù„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯:
- **YTM_Score:** Ø¨Ø§Ù„Ø§ØªØ± Ø¨ÙˆØ¯Ù† YTM Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø§Ù„Ø§ØªØ±ÛŒ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯.
- **Undervaluation_Score:** ØªÙØ§ÙˆØª Ø¨ÛŒÙ† Ù‚ÛŒÙ…Øª ØªØ­Ù„ÛŒÙ„â€ŒÚ¯Ø±Ø§Ù†Ù‡ Ùˆ Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ.
- **Bid-Ask_Spread_Score:** Ù‡Ø±Ú†Ù‡ Ø§Ø³Ù¾Ø±Ø¯ Ø¨Ø§Ø±Ø¨Ù†Ø¯-Ø¢Ø³Ú© Ø¨Ø§Ø±ÛŒÚ©â€ŒØªØ± Ø¨Ø§Ø´Ø¯ØŒ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø§Ù„Ø§ØªØ±ÛŒ.
- **Volume_Score:** Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ù„Ø§ØªØ±ØŒ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø§Ù„Ø§ØªØ±.
- **CI_Score:** Ø¹Ø±Ø¶ Ø¨Ø§Ø²Ù‡ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ù‡Ø±Ú†Ù‡ Ú©Ù…ØªØ± Ø¨Ø§Ø´Ø¯ØŒ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø§Ù„Ø§ØªØ±ÛŒ.

Ø§ÛŒÙ† Ø§Ù…ØªÛŒØ§Ø²Ø§Øª Ù†Ø±Ù…Ø§Ù„ÛŒØ²Ù‡ Ø´Ø¯Ù‡ Ùˆ Ø¨Ø§ ÙˆØ²Ù†â€ŒÙ‡Ø§ÛŒ Ù‚Ø§Ø¨Ù„ ØªÙ†Ø¸ÛŒÙ… ØªÙˆØ³Ø· Ú©Ø§Ø±Ø¨Ø± ØªØ±Ú©ÛŒØ¨ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ ØªØ§ Ø§Ù…ØªÛŒØ§Ø² Ú©Ù„ÛŒ Ù‡Ø± Ø§ÙˆØ±Ø§Ù‚ ØªØ¹ÛŒÛŒÙ† Ø´ÙˆØ¯ Ùˆ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§ÛŒÙ† Ø§Ù…ØªÛŒØ§Ø²Ù‡Ø§ØŒ Ø§ÙˆØ±Ø§Ù‚ Ø±ØªØ¨Ù‡â€ŒØ¨Ù†Ø¯ÛŒ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.

```python
def rank_bonds(priced_bonds_df: pd.DataFrame, logger: logging.Logger) -> pd.DataFrame:
    """
    Ranks bonds based on specified criteria.
    """
    try:
        df = priced_bonds_df.copy()

        # Ensure required columns are present
        required_columns = [
            'bond_name',
            'Expected Interest Rate at Maturity',
            'Analytic Price',
            'current_price',
            'bid_quote',
            'ask_quote',
            'volume',
            'Std Dev of Interest Rate at Maturity'
        ]
        missing_cols = [col for col in required_columns if col not in df.columns]
        if missing_cols:
            logger.error(f"Missing columns for ranking: {missing_cols}")
            st.error(f"Cannot rank bonds due to missing columns: {missing_cols}")
            return df

        # Calculate individual criterion scores
        # 1. Yield to Maturity (Expected Interest Rate at Maturity)
        df['YTM_Score'] = df['Expected Interest Rate at Maturity']

        # 2. Undervaluation Score (Analytic Price - Current Price)
        df['Undervaluation'] = df['Analytic Price'] - df['current_price']
        df['Undervaluation_Score'] = df['Undervaluation']

        # 3. Bid-Ask Spread Score
        df['Bid_Ask_Spread'] = df['ask_quote'] - df['bid_quote']
        df['Bid_Ask_Spread_Score'] = -df['Bid_Ask_Spread']  # Negative because narrower spread is better

        # 4. Volume Score
        df['Volume_Score'] = df['volume']

        # 5. Confidence Interval Width Score
        df['CI_Width'] = df['Upper Confidence Interval'] - df['Lower Confidence Interval']
        df['CI_Score'] = -df['CI_Width']  # Negative because narrower interval is better

        # Normalize scores between 0 and 1
        score_columns = ['YTM_Score', 'Undervaluation_Score', 'Bid_Ask_Spread_Score', 'Volume_Score', 'CI_Score']
        for col in score_columns:
            min_val = df[col].min()
            max_val = df[col].max()
            if max_val - min_val != 0:
                df[col] = (df[col] - min_val) / (max_val - min_val)
            else:
                df[col] = 0.5  # Assign a neutral score if no variation
            logger.info(f"Normalized {col}")

        # Allow users to adjust weights
        st.sidebar.subheader("5. Adjust Criteria Weights")
        ytm_weight = st.sidebar.slider("Yield to Maturity Weight", min_value=0.0, max_value=1.0, value=0.2, step=0.05)
        undervaluation_weight = st.sidebar.slider("Undervaluation Weight", min_value=0.0, max_value=1.0, value=0.2, step=0.05)
        spread_weight = st.sidebar.slider("Bid-Ask Spread Weight", min_value=0.0, max_value=1.0, value=0.2, step=0.05)
        volume_weight = st.sidebar.slider("Volume Weight", min_value=0.0, max_value=1.0, value=0.2, step=0.05)
        ci_weight = st.sidebar.slider("Confidence Interval Weight", min_value=0.0, max_value=1.0, value=0.2, step=0.05)

        # Ensure the weights sum to 1
        total_weight = ytm_weight + undervaluation_weight + spread_weight + volume_weight + ci_weight
        if total_weight == 0:
            st.error("At least one weight must be greater than zero.")
            return df
        ytm_weight /= total_weight
        undervaluation_weight /= total_weight
        spread_weight /= total_weight
        volume_weight /= total_weight
        ci_weight /= total_weight

        # Calculate overall score
        df['Overall_Score'] = (
            ytm_weight * df['YTM_Score'] +
            undervaluation_weight * df['Undervaluation_Score'] +
            spread_weight * df['Bid_Ask_Spread_Score'] +
            volume_weight * df['Volume_Score'] +
            ci_weight * df['CI_Score']
        )

        # Rank the bonds
        df['Rank'] = df['Overall_Score'].rank(ascending=False, method='min').astype(int)

        # Sort by rank
        df = df.sort_values(by='Overall_Score', ascending=False)

        # Select columns to display
        display_columns = [
            'Rank',
            'bond_name',
            'Overall_Score',
            'Expected Interest Rate at Maturity',
            'Analytic Price',
            'current_price',
            'Undervaluation',
            'Bid_Ask_Spread',
            'volume',
            'CI_Width'
        ]

        return df[display_columns]
    ```

---

### **Ûµ. Ù†ØªÛŒØ¬Ù‡â€ŒÚ¯ÛŒØ±ÛŒ**

Ø¨Ø§ ØªØ±Ú©ÛŒØ¨ Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ Ø¯Ù‚ÛŒÙ‚ Ù…Ø§Ù†Ù†Ø¯ ÙˆØ§Ø³ÛŒÚ†Ú© Ùˆ CIR Ø¨Ø§ Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ÛŒ ØªØ­Ù„ÛŒÙ„ÛŒ Ùˆ Ø¨ØµØ±ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ù…Ø§Ù†Ù†Ø¯ StreamlitØŒ Ø´Ù…Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ØªØµÙ…ÛŒÙ…Ø§Øª Ø³Ø±Ù…Ø§ÛŒÙ‡â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯Ø§Ù†Ù‡â€ŒØªØ±ÛŒ Ø¨Ú¯ÛŒØ±ÛŒØ¯. Ø§ÛŒÙ† Ø³ÛŒØ³ØªÙ… Ù†Ù‡ ØªÙ†Ù‡Ø§ Ù‚ÛŒÙ…Øª Ø§ÙˆØ±Ø§Ù‚ Ø±Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ø¨Ù„Ú©Ù‡ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ÛŒ Ù…ØªÙ†ÙˆØ¹ØŒ Ø§ÙˆØ±Ø§Ù‚ Ø±Ø§ Ø±ØªØ¨Ù‡â€ŒØ¨Ù†Ø¯ÛŒ Ùˆ Ø¨Ù‡ØªØ±ÛŒÙ† Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ù‡ Ø´Ù…Ø§ Ù…Ø¹Ø±ÙÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.

**Ø§Ú¯Ø± Ø³ÙˆØ§Ù„ ÛŒØ§ Ù†ÛŒØ§Ø² Ø¨Ù‡ ØªÙˆØ¶ÛŒØ­Ø§Øª Ø¨ÛŒØ´ØªØ±ÛŒ Ø¯Ø§Ø±ÛŒØ¯ØŒ Ø®ÙˆØ´Ø­Ø§Ù„ Ù…ÛŒâ€ŒØ´ÙˆÙ… Ú©Ù‡ Ú©Ù…Ú© Ú©Ù†Ù…!** ğŸ“ŠğŸ’¼
